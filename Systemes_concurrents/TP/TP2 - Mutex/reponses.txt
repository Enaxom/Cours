TP2 - Mutex
2App SN - Morgane CADEAU

1 - La classe Peterson fournie dans l'archive propose une implémentation du protocole d'exclusion mutuelle de Peterson vu en cours. Vérifiez et complétez éventuellement cette implémentation.
--------------------------------------------------------------------------------------------------
	L'implémentation semblait correcte. Pourtant, à l'exécution, on voit que les deux threads sont bloqué et attendent l'autre. Ceci est du aux variables Peterson.demande et Peterson.tour qui ont une valeur différente pour chaque thread à cause du cache.
	En ajoutant le mot clé volatile lors de la déclaration de ces variables, le problème est résolu et les threads voient la même valeur pour chaque variable.


2 - L'ordre des deux premières affectations de la méthode entrer() (lignes 29 et 30 : Peterson.demande[id] = true; et Peterson.tour = di;) est-il important ? Pourquoi ?
--------------------------------------------------------------------------------------------------
	L'ordre des deux premières affectations de la méthode entrer() a de l'importance. Imaginons que nous échangions les lignes 29 et 30. Si on a un processus 0 et 1, le processus 1 peut mettre tour à 0. Avant qu'il mette demande[1] = true, le processus 0 peut mettre tour à 1 puis demande[0] = true et n'attendra pas dans le while vu que le processus 0 n'a pas encore mis demande[1] à true. Les deux processus se retrouveraient donc en section critique, ce qui enfreint des critères d'exclusion mutuelle.


3 - La classe java.util.concurrent.atomic.AtomicBoolean propose une implantation logicielle de primitives de type TestAndSet, CompareAndSwap...
--------------------------------------------------------------------------------------------------
	a) Utiliser l'une de ces primitives pour réaliser un protocole d'exclusion mutuelle pour N processus.
		Voir ExclusionMutuelle.java
		Il n'est pas possible de réaliser un protocole d'exclusion mutuelle avec AtomicBoolean car celui-ci change la valeur de busy à true mais les autres processus voient que busy est à false avant que sa valeur ait changé. Ceci implique que plusieurs processus peuvent se retrouver en section critique.

	b) Réaliser une version vivace du protocole, garantissant que toute demande d'entrée en section critique finira par être servie.
		Voir ProtocoleVivace.java
		Le protocole est maintenant vivace, tous les processus vont finir par entrer en section critique. Cependant, comme vu ci-dessus, AtomicBoolean ne fonctionne pas comme voulu donc le protocole ne respecte pas l'exclusion mutuelle.

	c) Comparer les performances des deux versions, entre elles et par rapport à une version utilisant un bloc synchronized pour assurer l'exclusion mutuelle.
		En exécutant les 3 programmes ExclusionMutuelle, ProtocoleVivace, ProtocoleSynchronized (v1, v2, vSynchro) pendant 10 secondes chacun et en comptant le nombre de fois où une section critique est exécutée, voici les résultats trouvés en 3 essais :
			v1			150157	154279	160741 environ 155k
			v2			151461	162879	167010 environ 160k
			vSynchro	160542	163246	164326 environ 162k
		

